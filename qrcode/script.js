/**
 * QR Code Reader
 * Generated by Cursor AI
 * 
 * This script is a QR code reader that allows you to read QR codes from images, files, and camera.
 * 
 * It uses the jsQR library to decode QR codes.
 * 
 * It also allows you to copy the QR code content to the clipboard.
 * 
 */
class QRCodeReader {
    constructor() {
        this.initializeElements();
        this.bindEvents();
        this.stream = null;
        this.isCameraActive = false;
    }

    initializeElements() {
        // Buttons
        this.pasteBtn = document.getElementById('pasteBtn');
        this.uploadBtn = document.getElementById('uploadBtn');
        this.cameraBtn = document.getElementById('cameraBtn');
        this.copyBtn = document.getElementById('copyBtn');
        this.captureBtn = document.getElementById('captureBtn');
        this.closeCameraBtn = document.getElementById('closeCameraBtn');

        // Input elements
        this.fileInput = document.getElementById('fileInput');

        // Display elements
        this.resultSection = document.getElementById('resultSection');
        this.cameraSection = document.getElementById('cameraSection');
        this.originalImage = document.getElementById('originalImage');
        this.qrContent = document.getElementById('qrContent');
        this.errorMessage = document.getElementById('errorMessage');

        // Camera elements
        this.cameraVideo = document.getElementById('cameraVideo');
        this.cameraCanvas = document.getElementById('cameraCanvas');

        // Drop zone element
        this.dropZone = document.getElementById('dropZone');

        // QR Generation elements
        this.generateBtn = document.getElementById('generateBtn');
        this.generateSection = document.getElementById('generateSection');
        this.qrInput = document.getElementById('qrInput');
        this.generateQrBtn = document.getElementById('generateQrBtn');
        this.clearInputBtn = document.getElementById('clearInputBtn');
        this.qrPreviewContainer = document.getElementById('qrPreviewContainer');
        this.qrCanvas = document.getElementById('qrCanvas');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.copyBase64Btn = document.getElementById('copyBase64Btn');
        this.base64Display = document.getElementById('base64Display');
        this.base64Textarea = document.getElementById('base64Textarea');
        this.closeGenerateBtn = document.getElementById('closeGenerateBtn');
    }

    bindEvents() {
        // Button events
        this.pasteBtn.addEventListener('click', () => this.handlePaste());
        this.uploadBtn.addEventListener('click', () => this.fileInput.click());
        this.cameraBtn.addEventListener('click', () => this.startCamera());
        this.copyBtn.addEventListener('click', () => this.copyContent());
        this.captureBtn.addEventListener('click', () => this.captureFromCamera());
        this.closeCameraBtn.addEventListener('click', () => this.stopCamera());

        // File input event
        this.fileInput.addEventListener('change', (e) => this.handleFileUpload(e));

        // Global paste event
        document.addEventListener('paste', (e) => this.handleGlobalPaste(e));

        // Drag and drop events
        document.addEventListener('dragover', (e) => this.handleDragOver(e));
        document.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        document.addEventListener('drop', (e) => this.handleDrop(e));

        // QR Generation events
        this.generateBtn.addEventListener('click', () => this.showGenerateSection());
        this.generateQrBtn.addEventListener('click', () => this.generateQRCode());
        this.clearInputBtn.addEventListener('click', () => this.clearInput());
        this.downloadBtn.addEventListener('click', () => this.downloadQRCode());
        this.copyBase64Btn.addEventListener('click', () => this.copyBase64());
        this.closeGenerateBtn.addEventListener('click', () => this.hideGenerateSection());

        // Allow text pasting in QR input textarea
        this.qrInput.addEventListener('paste', (e) => {
            // Allow normal text pasting in the textarea
            e.stopPropagation();
            e.stopImmediatePropagation();
        });

        // Also prevent the global paste handler from interfering with any input/textarea
        this.qrInput.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                e.stopPropagation();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                // Don't trigger image paste if we're in an input/textarea or generate section
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' ||
                    this.generateSection.style.display !== 'none') {
                    return;
                }
                e.preventDefault();
                this.handlePaste();
            }
        });
    }

    async handlePaste() {
        try {
            const clipboardItems = await navigator.clipboard.read();
            for (const clipboardItem of clipboardItems) {
                for (const type of clipboardItem.types) {
                    if (type.startsWith('image/')) {
                        const blob = await clipboardItem.getType(type);
                        await this.processImage(blob);
                        return;
                    }
                }
            }
            this.showError('No image found in clipboard. Please copy an image first.');
        } catch (error) {
            console.error('Paste error:', error);
            this.showError('Failed to read from clipboard. Please try uploading a file instead.');
        }
    }

    handleGlobalPaste(e) {
        const items = e.clipboardData?.items;
        if (!items) return;

        // Check if the target is an input or textarea - allow normal pasting
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        // Check if we're in the generate section - allow normal text pasting
        if (this.generateSection.style.display !== 'none') {
            return;
        }

        for (let item of items) {
            if (item.type.startsWith('image/')) {
                e.preventDefault();
                const file = item.getAsFile();
                this.processImage(file);
                return;
            }
        }
    }

    handleFileUpload(e) {
        const file = e.target.files[0];
        if (file && file.type.startsWith('image/')) {
            this.processImage(file);
        } else {
            this.showError('Please select a valid image file.');
        }
        // Reset file input
        e.target.value = '';
    }

    handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();

        // Check if any of the dragged items are files
        if (e.dataTransfer.types.includes('Files')) {
            this.showDropZone();
        }
    }

    handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();

        // Only hide drop zone if we're leaving the document entirely
        if (!e.relatedTarget || !document.contains(e.relatedTarget)) {
            this.hideDropZone();
        }
    }

    handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();

        this.hideDropZone();

        const files = Array.from(e.dataTransfer.files);
        const imageFile = files.find(file => file.type.startsWith('image/'));

        if (imageFile) {
            this.processImage(imageFile);
        } else {
            this.showError('Please drop a valid image file.');
        }
    }

    showDropZone() {
        this.dropZone.classList.add('active');
    }

    hideDropZone() {
        this.dropZone.classList.remove('active');
    }

    showGenerateSection() {
        // Hide other sections but don't stop camera if it's already running
        this.resultSection.style.display = 'none';
        this.cameraSection.style.display = 'none';
        this.generateSection.style.display = 'block';
        this.qrInput.focus();
    }

    hideGenerateSection() {
        this.generateSection.style.display = 'none';
        this.qrPreviewContainer.style.display = 'none';
        this.base64Display.style.display = 'none';
        this.qrInput.value = '';
    }

    hideAllSections() {
        this.resultSection.style.display = 'none';
        this.cameraSection.style.display = 'none';
        this.generateSection.style.display = 'none';
        this.stopCamera();
    }

    async generateQRCode() {
        const text = this.qrInput.value.trim();

        if (!text) {
            this.showError('Please enter some text or URL to generate a QR code.');
            return;
        }

        // Check if QRCode library is available
        if (typeof QRCode === 'undefined') {
            this.showError('QR Code generation library not loaded. Please refresh the page and try again.');
            return;
        }

        try {
            this.hideError();

            // Create a temporary div for QR code generation
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            document.body.appendChild(tempDiv);

            // Generate QR code using qrcodejs library
            const qr = new QRCode(tempDiv, {
                text: text,
                width: 192, // Smaller size to accommodate padding
                height: 192,
                colorDark: '#000000',
                colorLight: '#FFFFFF',
                correctLevel: QRCode.CorrectLevel.H
            });

            // Wait a bit for the QR code to render
            setTimeout(() => {
                // Try to get the generated image or canvas
                let qrImage = tempDiv.querySelector('img');
                let qrCanvasElem = tempDiv.querySelector('canvas');
                const canvas = this.qrCanvas;
                const padding = 32; // 32px padding on each side
                const qrSize = 256 - (padding * 2); // QR code size with padding
                canvas.width = 256;
                canvas.height = 256;

                const ctx = canvas.getContext('2d');

                // Fill with white background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (qrImage && qrImage.src && qrImage.src.startsWith('data:image')) {
                    // Draw the QR code image with padding
                    ctx.drawImage(qrImage, padding, padding, qrSize, qrSize);
                } else if (qrCanvasElem) {
                    // Draw the QR code canvas with padding
                    ctx.drawImage(qrCanvasElem, padding, padding, qrSize, qrSize);
                } else {
                    this.showError('Failed to generate QR code image.');
                    document.body.removeChild(tempDiv);
                    return;
                }

                // Show the preview container
                this.qrPreviewContainer.style.display = 'block';
                this.qrPreviewContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                // Clean up
                document.body.removeChild(tempDiv);
            }, 100);

        } catch (error) {
            console.error('QR generation error:', error);
            this.showError('Failed to generate QR code. Please try again.');
        }
    }

    clearInput() {
        this.qrInput.value = '';
        this.qrPreviewContainer.style.display = 'none';
        this.base64Display.style.display = 'none';
        this.qrInput.focus();
    }

    async downloadQRCode() {
        try {
            const canvas = this.qrCanvas;
            const link = document.createElement('a');
            link.download = 'qrcode.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        } catch (error) {
            console.error('Download error:', error);
            this.showError('Failed to download QR code.');
        }
    }

    async copyBase64() {
        try {
            const canvas = this.qrCanvas;
            const base64Data = canvas.toDataURL('image/png');

            // Show the base64 display
            this.base64Textarea.value = base64Data;
            this.base64Display.style.display = 'block';

            // Copy to clipboard
            await navigator.clipboard.writeText(base64Data);

            // Show success feedback
            this.showCopyBase64Success();

        } catch (error) {
            console.error('Base64 copy error:', error);
            this.showError('Failed to copy base64 data.');
        }
    }

    showCopyBase64Success() {
        const originalText = this.copyBase64Btn.innerHTML;
        this.copyBase64Btn.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="20,6 9,17 4,12"></polyline>
            </svg>
            Copied!
        `;
        this.copyBase64Btn.style.background = '#28a745';

        setTimeout(() => {
            this.copyBase64Btn.innerHTML = originalText;
            this.copyBase64Btn.style.background = '#6c757d';
        }, 2000);
    }

    async processImage(file) {
        try {
            this.hideError();
            this.showLoading();

            // Display the original image
            const imageUrl = URL.createObjectURL(file);
            this.originalImage.src = imageUrl;
            this.originalImage.onload = () => URL.revokeObjectURL(imageUrl);

            // Decode QR code
            const result = await this.decodeQRCode(file);

            if (result) {
                this.displayResult(result);
            } else {
                this.showError('No QR code found in the image. Please try with a different image.');
            }
        } catch (error) {
            console.error('Processing error:', error);
            this.showError('Failed to process the image. Please try again.');
        } finally {
            this.hideLoading();
        }
    }

    async decodeQRCode(file) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                // Set canvas size to image size
                canvas.width = img.width;
                canvas.height = img.height;

                // Draw image on canvas
                ctx.drawImage(img, 0, 0);

                // Get image data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Decode QR code using jsQR
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: "dontInvert",
                });

                resolve(code ? code.data : null);
            };

            img.onerror = () => resolve(null);
            img.src = URL.createObjectURL(file);
        });
    }

    displayResult(content) {
        this.qrContent.textContent = content;
        this.qrContent.classList.add('has-content');

        // Hide other sections but don't stop camera if it's already running
        this.cameraSection.style.display = 'none';
        this.generateSection.style.display = 'none';
        this.resultSection.style.display = 'grid';
        this.resultSection.classList.add('success');

        // Scroll to result
        this.resultSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

        // Remove success animation after delay
        setTimeout(() => {
            this.resultSection.classList.remove('success');
        }, 600);
    }

    async startCamera() {
        try {
            this.hideError();
            this.stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            });

            this.cameraVideo.srcObject = this.stream;

            // Ensure video element has correct attributes for autoplay
            this.cameraVideo.autoplay = true;
            this.cameraVideo.playsInline = true;
            this.cameraVideo.muted = true; // Required for autoplay in some browsers

            // Hide other sections but don't stop camera if it's already running
            this.resultSection.style.display = 'none';
            this.generateSection.style.display = 'none';
            this.cameraSection.style.display = 'block';
            this.isCameraActive = true;

            // Start continuous scanning
            this.startContinuousScanning();

        } catch (error) {
            console.error('Camera error:', error);
            this.showError('Failed to access camera. Please check permissions and try again.');
        }
    }

    stopCamera() {
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        this.cameraSection.style.display = 'none';
        this.isCameraActive = false;
        this.stopContinuousScanning();
    }

    startContinuousScanning() {
        this.scanInterval = setInterval(() => {
            if (this.isCameraActive) {
                this.scanFromCamera();
            }
        }, 1000); // Scan every second
    }

    stopContinuousScanning() {
        if (this.scanInterval) {
            clearInterval(this.scanInterval);
            this.scanInterval = null;
        }
    }

    scanFromCamera() {
        if (!this.isCameraActive || this.cameraVideo.videoWidth === 0) return;

        const canvas = this.cameraCanvas;
        const ctx = canvas.getContext('2d');

        canvas.width = this.cameraVideo.videoWidth;
        canvas.height = this.cameraVideo.videoHeight;

        ctx.drawImage(this.cameraVideo, 0, 0);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const code = jsQR(imageData.data, imageData.width, imageData.height, {
            inversionAttempts: "dontInvert",
        });

        if (code) {
            this.stopCamera();
            this.displayResult(code.data);

            // Show the captured frame as the original image
            canvas.toBlob((blob) => {
                const imageUrl = URL.createObjectURL(blob);
                this.originalImage.src = imageUrl;
                this.originalImage.onload = () => URL.revokeObjectURL(imageUrl);
            });
        }
    }

    captureFromCamera() {
        this.scanFromCamera();
    }

    async copyContent() {
        const content = this.qrContent.textContent;
        if (!content) return;

        try {
            await navigator.clipboard.writeText(content);
            this.showCopySuccess();
        } catch (error) {
            console.error('Copy error:', error);
            this.showError('Failed to copy to clipboard.');
        }
    }

    showCopySuccess() {
        const originalText = this.copyBtn.innerHTML;
        this.copyBtn.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="20,6 9,17 4,12"></polyline>
            </svg>
            Copied!
        `;
        this.copyBtn.style.background = '#28a745';

        setTimeout(() => {
            this.copyBtn.innerHTML = originalText;
            this.copyBtn.style.background = '#28a745';
        }, 2000);
    }

    showLoading() {
        this.pasteBtn.innerHTML = '<div class="loading"></div> Processing...';
        this.pasteBtn.disabled = true;
    }

    hideLoading() {
        this.pasteBtn.innerHTML = `
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
            </svg>
            Paste Image
        `;
        this.pasteBtn.disabled = false;
    }

    showError(message) {
        this.errorMessage.textContent = message;
        this.errorMessage.style.display = 'block';
        this.errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    hideError() {
        this.errorMessage.style.display = 'none';
    }
}

// Initialize the QR Code Reader when the page loads
document.addEventListener('DOMContentLoaded', () => {
    // Check if QRCode library is loaded
    if (typeof QRCode === 'undefined') {
        console.warn('QRCode library not loaded. QR generation will not work.');
    }

    new QRCodeReader();
});

// Handle page visibility changes to stop camera when tab is not active
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        const qrReader = window.qrReader;
        if (qrReader && qrReader.isCameraActive) {
            qrReader.stopCamera();
        }
    }
}); 
